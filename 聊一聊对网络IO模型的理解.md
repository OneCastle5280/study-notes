## 简单聊一聊对网络 I/O 模型的理解
### 1. 前言
刚开始我对网络 i/o 模型的理解很模糊，很难捋清各种 i/o 模型之间的区别；因为最近在学习 rpc 框架的底层工作原理，其中网络通讯模块涉及到了 i/o 模型相关的知识；
然后我发现我对网络i/o模型这一块知识并不是那么了解。经过几天的学习和朋友的讨论，对网络 i/o 模型有了一定的理解。

### 2. I/O 操作与操作系统的关系
首先，我想先简单聊聊程序在进行 I/O 操作的时候，跟操作系统之间的交互是怎么样的。

I/O 根据是否发生了网络传输区分为本地 I/O 和网络 I/O ；本地 I/O 就是程序在本机进行文件读取和生成，网络 I/O 则是程序通过机器的网络设备（例如网卡）进行文件流传输；无论是
本地 I/O 还是网络 I/O 程序都需要借助操作系统的力量，需要操作系统调度切换到内核态才能执行相应的一些命令，例如：从磁盘中读取指定文件字节流/往磁盘文件写入字节流；将字节流通过网卡发送到网络中
。这些都只有内核态才能执行的能力；所以我们程序进行 I/O 操作，一定会涉及到用户态/内核态的切换。
### 3. 发生 I/O 操作时，程序与操作系统的交互流程
不一样的 I/O 模型可能会有不一样的流程，我们先简单划分一下 I/O 模型；

#### 3.1 阻塞 I/O 模型
程序要进行 I/O 操作时，我们上面说到，需要操作系统切换内核态才能对文件进行读/写的操作，操作系统提供了特殊的 API，程序通过调用特殊的 API 就能获得文件读写的能力。这特殊 API 有一个专业名词 `系统调用`。

例如：程序需要对文件进行读取，需要调用操作系统的 `read()` 方法，此时操作系统会切换到内核态，调用硬件能力，将文件内容从磁盘读取到内核缓冲区，然后通过 CPU 将内核缓冲区的数据拷贝到用户态；然后再从内核态切回用户态。
这样程序就完成了对文件的读取操作。这里涉及到几个步骤：
1. 线程调用 `read()` 通知操作系统需要对文件进行读取
2. 操作系统从用户态转化成内核态
3. 操作系统在内核态操作调用硬件能力，将文件拷贝到内核缓冲区
4. 然后将内核缓冲区的数据拷贝到用户态
5. 线程成功读取到文件内容

在这个流程中，在调用 `read()` 之后，线程则一直阻塞等待操作系统返回数据，线程是阻塞等待的，线程不能去执行其他操作；

##### 优点
* 实现简单、使用简单易懂
##### 缺点
* 无法处理大量 I/O 请求的场景。一个 I/O 请求就会占用一个线程，并且在进行`系统调用`的时候，线程是阻塞的，无法执行其他操作。如果一瞬间有比较多的 I/O 请求，就需要创建对应数量的线程，线程的创建与维护都是非常消耗内存和CPU资源的。

#### 3.2 非阻塞 I/O 模型
阻塞 I/O 的阻塞是指线程在进行系统调用之后，阻塞等待系统调用(例：`read()`)的结果，期间线程不能做其他操作；非阻塞 I/O 则是指线程在进行系统调用之后，不需要阻塞等待 I/O 操作的处理完成。流程如下：
1. 线程进行系统调用，通知操作系统需要对文件进行读取
2. 操作系统立即返回此次系统调用的结果：文件已经准备好了或者还在处理中
3. 因为线程是马上获取到系统调用的响应，线程是非阻塞状态的；
4. 但是因为线程无法知道操作系统什么时候能把文件准备好，所以需要一直询问操作系统：你准备好了吗？你准备好了吗？（即一直进行系统调用）
5. 直到操作系统把文件准备好了，这个时候系统调用就会返回程序：文件已经准备好了
6. 此时，线程就能够成功读取到文件内容

##### 优点
* 线程在进行系统调用之后，不用进入阻塞状态
##### 缺点
* todo 是否同样不适配大量 I/O 请求的场景？待确认
* 因为线程无法知道操作系统什么时候才能把文件准备好，只能一直轮询，cpu 资源都消耗在系统调用询问结果上了，一直在空转。

#### 3.3 I/O 多路复用模型




















