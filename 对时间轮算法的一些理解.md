# 对时间轮算法的一些理解
## 1. 前言
之前在学习了解 `rpc` 底层工作原理的时候，好奇 rpc 的超时判断、定时心跳检测这些定时类的功能是如何实现的；了解到可以通过时间轮算法来进行实现；然后我就在思考两个问题：
1. 时间轮有什么优点，为什么使用这个算法来实现
2. 如果让我自己手写一个时间轮能不能写？

## 2. 为什么选择时间轮
假设我们不用时间轮来实现定时任务，我们应该如何来实现超时或者定时任务？最容易想到的一种方式就是：起个线程，sleep 指定时间，然后再继续往下执行，这个是最简单的实现思路。但
如果定时任务越来越多，一个定时任务就要一个线程，太浪费了；资源浪费和扩展性差。

还有一种思路是：用一个队列来记录定时任务，起一个线程，然后每隔固定时长就去扫描队列，查看是否存在需要执行的任务。这种实现思路也很简单，并且就算有多个定时任务也只需要单个线程扫描判断即可，但是有可能会存在 CPU 空转的问题存在：即
一段时间内都没有定时任务需要执行。

## 3. 时间轮算法
时间轮算法其实也并不复杂，简单来讲，就是将时间固定切分为多个时间槽，并用一个指针周期性的扫描每一个槽来处理定时任务。
例如：我们把一分钟切分成 60 个槽，指针每一秒移动一次，然后判断槽关联的任务是否需要触发执行。这就是时间轮的核心思想。

所以时间轮算法的核心组件就是两个：1. 用来表示将时间切分为固定份数的数据结构 2. 用来存储定时任务的数据结构

**工作流程**：

我们以上面将 1 分钟拆分成 60 个槽作为例子，讲讲时间轮的工作流程：假设我们有两个定时任务A、B，A 希望在 30 s 执行，B 希望在 1 min 40 s 之后再执行。
这里有一个问题，时间轮一圈只能表示 1 分钟，但是 B 任务期望的执行时间 > 1 分钟，可以通过记录周期来表示这种，即 B 任务是在第二轮扫描的时候才执行，第一轮扫描的时候会判断
时间轮内置指针（即线程）每隔 1s 就扫描一个槽，判断槽上的定时任务是否应该被执行；当线程扫描到第 30 个时间槽，发现 A 任务已经到了期望执行的时间。然后继续扫描，当线程扫描到第 40 个时间槽，发现 B 任务还不能执行，因为 B 任务是期望 1min 40s 后执行，所以本周期暂不执行，
等到下一周期在执行。

## 4. 算法实现
根据时间轮的核心思想，我们实现一个简易版本的时间轮工具
